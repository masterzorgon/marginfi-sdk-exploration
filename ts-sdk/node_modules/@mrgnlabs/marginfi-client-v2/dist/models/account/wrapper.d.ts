import { Amount, InstructionsWrapper } from "@mrgnlabs/mrgn-common";
import { Address } from "@coral-xyz/anchor";
import { AccountMeta, Commitment, PublicKey, TransactionInstruction, Signer, AddressLookupTableAccount, VersionedTransaction } from "@solana/web3.js";
import BigNumber from "bignumber.js";
import { MakeBorrowIxOpts, MakeDepositIxOpts, MakeRepayIxOpts, MakeWithdrawIxOpts, MarginfiClient, MarginfiGroup, MarginfiIdlType } from "../..";
import { MarginfiAccount, MarginRequirementType, MarginfiAccountRaw } from "./pure";
import { Bank } from "../bank";
import { Balance } from "../balance";
export interface SimulationResult {
    banks: Map<string, Bank>;
    marginfiAccount: MarginfiAccountWrapper;
}
export interface FlashLoanArgs {
    ixs: TransactionInstruction[];
    signers?: Signer[];
    addressLookupTableAccounts?: AddressLookupTableAccount[];
}
declare class MarginfiAccountWrapper {
    private readonly client;
    readonly address: PublicKey;
    private _marginfiAccount;
    /**
     * @internal
     */
    private constructor();
    static fetch(marginfiAccountPk: Address, client: MarginfiClient, commitment?: Commitment): Promise<MarginfiAccountWrapper>;
    static fromAccountParsed(marginfiAccountPk: Address, client: MarginfiClient, accountData: MarginfiAccountRaw): MarginfiAccountWrapper;
    static fromAccountDataRaw(marginfiAccountPk: PublicKey, client: MarginfiClient, marginfiAccountRawData: Buffer, idl: MarginfiIdlType): MarginfiAccountWrapper;
    get authority(): PublicKey;
    get group(): MarginfiGroup;
    get balances(): Balance[];
    get data(): MarginfiAccount;
    get pureAccount(): MarginfiAccount;
    /** @internal */
    private get _program();
    /** @internal */
    private get _config();
    get activeBalances(): Balance[];
    get isDisabled(): boolean;
    get isFlashLoanEnabled(): boolean;
    get isTransferAccountAuthorityEnabled(): boolean;
    getBalance(bankPk: PublicKey): Balance;
    canBeLiquidated(): boolean;
    computeHealthComponents(marginRequirement: MarginRequirementType, excludedBanks?: PublicKey[]): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeFreeCollateral(opts?: {
        clamped?: boolean;
    }): BigNumber;
    computeHealthComponentsWithoutBias(marginRequirement: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeAccountValue(): BigNumber;
    computeMaxBorrowForBank(bankAddress: PublicKey, opts?: {
        volatilityFactor?: number;
    }): BigNumber;
    computeMaxWithdrawForBank(bankAddress: PublicKey, opts?: {
        volatilityFactor?: number;
    }): BigNumber;
    computeMaxLiquidatableAssetAmount(assetBankAddress: PublicKey, liabilityBankAddress: PublicKey): BigNumber;
    computeLiquidationPriceForBank(bankAddress: PublicKey): number | null;
    computeLiquidationPriceForBankAmount(bankAddress: PublicKey, isLending: boolean, amount: number): number | null;
    computeNetApy(): number;
    computeLoopingParams(principal: Amount, targetLeverage: number, depositBankAddress: PublicKey, borrowBankAddress: PublicKey): {
        borrowAmount: BigNumber;
        totalDepositAmount: BigNumber;
    };
    makePriorityFeeIx(priorityFeeUi?: number): TransactionInstruction[];
    makeComputeBudgetIx(): TransactionInstruction[];
    makeSetupIx(banks: PublicKey[]): Promise<TransactionInstruction[]>;
    repayWithCollat(repayAmount: Amount, withdrawAmount: Amount, borrowBankAddress: PublicKey, depositBankAddress: PublicKey, withdrawAll: boolean | undefined, repayAll: boolean | undefined, swapIxs: TransactionInstruction[], swapLookupTables: AddressLookupTableAccount[], priorityFeeUi?: number): Promise<string>;
    simulateRepayWithCollat(repayAmount: Amount, withdrawAmount: Amount, borrowBankAddress: PublicKey, depositBankAddress: PublicKey, withdrawAll: boolean | undefined, repayAll: boolean | undefined, swapIxs: TransactionInstruction[], addressLookupTableAccounts: AddressLookupTableAccount[]): Promise<SimulationResult>;
    makeRepayWithCollatTx(repayAmount: Amount, withdrawAmount: Amount, borrowBankAddress: PublicKey, depositBankAddress: PublicKey, withdrawAll: boolean | undefined, repayAll: boolean | undefined, swapIxs: TransactionInstruction[], swapLookupTables: AddressLookupTableAccount[], priorityFeeUi?: number): Promise<{
        transaction: VersionedTransaction;
        addressLookupTableAccounts: AddressLookupTableAccount[];
    }>;
    loop(depositAmount: Amount, borrowAmount: Amount, depositBankAddress: PublicKey, borrowBankAddress: PublicKey, swapIxs: TransactionInstruction[], swapLookupTables: AddressLookupTableAccount[], priorityFeeUi?: number): Promise<string | {
        flashloanTx: VersionedTransaction;
        addressLookupTableAccounts: AddressLookupTableAccount[];
    }>;
    simulateLoop(depositAmount: Amount, borrowAmount: Amount, depositBankAddress: PublicKey, borrowBankAddress: PublicKey, swapIxs: TransactionInstruction[], swapLookupTables: AddressLookupTableAccount[], priorityFeeUi?: number): Promise<SimulationResult>;
    makeLoopTx(depositAmount: Amount, borrowAmount: Amount, depositBankAddress: PublicKey, borrowBankAddress: PublicKey, swapIxs: TransactionInstruction[], swapLookupTables: AddressLookupTableAccount[], priorityFeeUi?: number, createAtas?: boolean): Promise<{
        transaction: VersionedTransaction;
        addressLookupTableAccounts: AddressLookupTableAccount[];
    }>;
    makeDepositIx(amount: Amount, bankAddress: PublicKey, opt?: MakeDepositIxOpts): Promise<InstructionsWrapper>;
    deposit(amount: Amount, bankAddress: PublicKey, opt?: MakeDepositIxOpts): Promise<string>;
    simulateDeposit(amount: Amount, bankAddress: PublicKey): Promise<SimulationResult>;
    makeRepayIx(amount: Amount, bankAddress: PublicKey, repayAll?: boolean, opt?: MakeRepayIxOpts): Promise<InstructionsWrapper>;
    repay(amount: Amount, bankAddress: PublicKey, repayAll?: boolean, opt?: MakeRepayIxOpts): Promise<string>;
    simulateRepay(amount: Amount, bankAddress: PublicKey, repayAll?: boolean): Promise<SimulationResult>;
    makeWithdrawIx(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, opt?: MakeWithdrawIxOpts): Promise<InstructionsWrapper>;
    withdraw(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, opt?: MakeWithdrawIxOpts): Promise<string>;
    simulateWithdraw(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean): Promise<SimulationResult>;
    makeBorrowIx(amount: Amount, bankAddress: PublicKey, opt?: MakeBorrowIxOpts): Promise<InstructionsWrapper>;
    borrow(amount: Amount, bankAddress: PublicKey, opt?: MakeBorrowIxOpts): Promise<string>;
    simulateBorrow(amount: Amount, bankAddress: PublicKey): Promise<SimulationResult>;
    makeWithdrawEmissionsIx(bankAddress: PublicKey): Promise<InstructionsWrapper>;
    withdrawEmissions(bankAddress: PublicKey): Promise<string>;
    makeLendingAccountLiquidateIx(liquidateeMarginfiAccount: MarginfiAccount, assetBankAddress: PublicKey, assetQuantityUi: Amount, liabBankAddress: PublicKey): Promise<InstructionsWrapper>;
    lendingAccountLiquidate(liquidateeMarginfiAccount: MarginfiAccount, assetBankAddress: PublicKey, assetQuantityUi: Amount, liabBankAddress: PublicKey): Promise<string>;
    makeBeginFlashLoanIx(endIndex: number): Promise<InstructionsWrapper>;
    makeEndFlashLoanIx(projectedActiveBalances: PublicKey[]): Promise<InstructionsWrapper>;
    flashLoan(args: FlashLoanArgs): Promise<string>;
    buildFlashLoanTx(args: FlashLoanArgs, lookupTables?: AddressLookupTableAccount[]): Promise<VersionedTransaction>;
    makeTransferAccountAuthorityIx(newAccountAuthority: PublicKey): Promise<InstructionsWrapper>;
    transferAccountAuthority(newAccountAuthority: PublicKey): Promise<string>;
    getHealthCheckAccounts(mandatoryBanks?: Bank[], excludedBanks?: Bank[]): AccountMeta[];
    private static _fetchAccountData;
    static encode(decoded: MarginfiAccountRaw, idl: MarginfiIdlType): Promise<Buffer>;
    reload(): Promise<void>;
    private _updateFromAccountParsed;
    describe(): string;
}
export { MarginfiAccountWrapper };
//# sourceMappingURL=wrapper.d.ts.map