"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MARGINFI_SPONSORED_SHARD_ID = exports.PYTH_SPONSORED_SHARD_ID = void 0;
exports.getBankVaultSeeds = getBankVaultSeeds;
exports.getBankVaultAuthority = getBankVaultAuthority;
exports.makeWrapSolIxs = makeWrapSolIxs;
exports.makeUnwrapSolIx = makeUnwrapSolIx;
exports.makeVersionedTransaction = makeVersionedTransaction;
exports.makePriorityFeeIx = makePriorityFeeIx;
exports.feedIdToString = feedIdToString;
exports.buildFeedIdMap = buildFeedIdMap;
exports.findOracleKey = findOracleKey;
exports.findPythPushOracleAddress = findPythPushOracleAddress;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const types_1 = require("./types");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const _1 = require(".");
function getBankVaultSeeds(type) {
    switch (type) {
        case types_1.BankVaultType.LiquidityVault:
            return constants_1.PDA_BANK_LIQUIDITY_VAULT_SEED;
        case types_1.BankVaultType.InsuranceVault:
            return constants_1.PDA_BANK_INSURANCE_VAULT_SEED;
        case types_1.BankVaultType.FeeVault:
            return constants_1.PDA_BANK_FEE_VAULT_SEED;
        default:
            throw Error(`Unknown vault type ${type}`);
    }
}
function getBankVaultAuthoritySeeds(type) {
    switch (type) {
        case types_1.BankVaultType.LiquidityVault:
            return constants_1.PDA_BANK_LIQUIDITY_VAULT_AUTH_SEED;
        case types_1.BankVaultType.InsuranceVault:
            return constants_1.PDA_BANK_INSURANCE_VAULT_AUTH_SEED;
        case types_1.BankVaultType.FeeVault:
            return constants_1.PDA_BANK_FEE_VAULT_AUTH_SEED;
        default:
            throw Error(`Unknown vault type ${type}`);
    }
}
/**
 * Compute authority PDA for a specific marginfi group bank vault
 */
function getBankVaultAuthority(bankVaultType, bankPk, programId) {
    return web3_js_1.PublicKey.findProgramAddressSync([getBankVaultAuthoritySeeds(bankVaultType), bankPk.toBuffer()], programId);
}
function makeWrapSolIxs(walletAddress, amount) {
    const address = (0, mrgn_common_1.getAssociatedTokenAddressSync)(mrgn_common_1.NATIVE_MINT, walletAddress, true);
    const ixs = [(0, mrgn_common_1.createAssociatedTokenAccountIdempotentInstruction)(walletAddress, address, walletAddress, mrgn_common_1.NATIVE_MINT)];
    if (amount.gt(0)) {
        const nativeAmount = (0, mrgn_common_1.uiToNative)(amount, 9).toNumber() + 10000;
        ixs.push(web3_js_1.SystemProgram.transfer({ fromPubkey: walletAddress, toPubkey: address, lamports: nativeAmount }), (0, mrgn_common_1.createSyncNativeInstruction)(address));
    }
    return ixs;
}
function makeUnwrapSolIx(walletAddress) {
    const address = (0, mrgn_common_1.getAssociatedTokenAddressSync)(mrgn_common_1.NATIVE_MINT, walletAddress, true); // We allow off curve addresses here to support Fuse.
    return (0, mrgn_common_1.createCloseAccountInstruction)(address, walletAddress, walletAddress);
}
async function makeVersionedTransaction(blockhash, transaction, payer, addressLookupTables) {
    const message = new web3_js_1.TransactionMessage({
        instructions: transaction.instructions,
        payerKey: payer,
        recentBlockhash: blockhash,
    });
    const versionedMessage = addressLookupTables
        ? message.compileToV0Message(addressLookupTables)
        : message.compileToLegacyMessage();
    return new web3_js_1.VersionedTransaction(versionedMessage);
}
function makePriorityFeeIx(priorityFeeUi) {
    const priorityFeeIx = [];
    const limitCU = 1_400_000;
    let microLamports = 1;
    if (priorityFeeUi) {
        // if priority fee is above 0.2 SOL discard it for safety reasons
        const isAbsurdPriorityFee = priorityFeeUi > 0.2;
        if (!isAbsurdPriorityFee) {
            const priorityFeeMicroLamports = priorityFeeUi * web3_js_1.LAMPORTS_PER_SOL * 1_000_000;
            microLamports = Math.round(priorityFeeMicroLamports / limitCU);
        }
    }
    priorityFeeIx.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports,
    }));
    return priorityFeeIx;
}
function feedIdToString(feedId) {
    return feedId.toBuffer().toString('hex');
}
async function buildFeedIdMap(bankConfigs, connection) {
    const feedIdMap = new Map();
    const feedIdsWithAddresses = bankConfigs.filter((bankConfig) => (0, _1.parseOracleSetup)(bankConfig.oracleSetup) == _1.OracleSetup.PythPushOracle).map((bankConfig) => {
        let feedId = bankConfig.oracleKeys[0].toBuffer();
        return {
            feedId, addresses: [
                findPythPushOracleAddress(feedId, constants_1.PYTH_PUSH_ORACLE_ID, exports.PYTH_SPONSORED_SHARD_ID),
                findPythPushOracleAddress(feedId, constants_1.PYTH_PUSH_ORACLE_ID, exports.MARGINFI_SPONSORED_SHARD_ID),
            ]
        };
    }).flat();
    const addressess = feedIdsWithAddresses.map((feedIdWithAddress) => feedIdWithAddress.addresses).flat();
    const accountInfos = [];
    const chunkSize = 25;
    for (let i = 0; i < addressess.length; i += chunkSize) {
        const chunk = addressess.slice(i, i + chunkSize);
        const accountInfosChunk = await connection.getMultipleAccountsInfo(chunk);
        accountInfos.push(...accountInfosChunk);
    }
    for (let i = 0; i < feedIdsWithAddresses.length; i++) {
        const oraclesStartIndex = i * 2;
        const pythSponsoredOracle = accountInfos[oraclesStartIndex];
        const mfiSponsoredOracle = accountInfos[oraclesStartIndex + 1];
        const feedId = feedIdsWithAddresses[i].feedId.toString('hex');
        if (mfiSponsoredOracle) {
            feedIdMap.set(feedId, feedIdsWithAddresses[i].addresses[1]);
        }
        else if (pythSponsoredOracle) {
            feedIdMap.set(feedId, feedIdsWithAddresses[i].addresses[0]);
        }
        else {
            throw new Error(`No oracle found for feedId: ${feedId}, either Pyth or MFI sponsored oracle must exist`);
        }
    }
    return feedIdMap;
}
function findOracleKey(bankConfig, feedMap) {
    const oracleSetup = bankConfig.oracleSetup;
    let oracleKey = bankConfig.oracleKeys[0];
    if (oracleSetup == _1.OracleSetup.PythPushOracle) {
        const feedId = feedIdToString(oracleKey);
        oracleKey = feedMap.get(feedId);
    }
    return oracleKey;
}
exports.PYTH_SPONSORED_SHARD_ID = 0;
exports.MARGINFI_SPONSORED_SHARD_ID = 3301;
function findPythPushOracleAddress(feedId, programId, shardId) {
    const shardBytes = u16ToArrayBufferLE(shardId);
    return web3_js_1.PublicKey.findProgramAddressSync([shardBytes, feedId], programId)[0];
}
function u16ToArrayBufferLE(value) {
    // Create a buffer of 2 bytes
    const buffer = new ArrayBuffer(2);
    const dataView = new DataView(buffer);
    // Set the Uint16 value in little-endian order
    dataView.setUint16(0, value, true);
    // Return the buffer
    return new Uint8Array(buffer);
}
